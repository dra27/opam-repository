From 3b77bdc4cb9001d163617919b4b1fc8332d9330c Mon Sep 17 00:00:00 2001
From: Xavier Leroy <xavierleroy@users.noreply.github.com>
Date: Fri, 5 Mar 2021 19:14:07 +0100
Subject: [PATCH] Dynamically allocate the alternate signal stack

In Glibc 2.34 and later, SIGSTKSZ may not be a compile-time constant.
It is no longer possible to statically allocate the alternate signal
stack for the main thread, as we've been doing for the last 25 years.

This commit implements dynamic allocation of the alternate signal stack
even for the main thread.  It reuses the code already in place to allocate
the alternate signal stack for other threads.

The alternate signal stack is freed when the main OCaml code / an OCaml thread
stops.

(partial back-port of PR#10266 and PR#10726)
---
 asmrun/fail.c        |  7 ++++++-
 asmrun/signals_asm.c | 47 +++++++++++++++++++++++++++++++++++++++++---
 asmrun/startup.c     |  3 +++
 byterun/sys.c        |  5 +++++
 4 files changed, 58 insertions(+), 4 deletions(-)

diff --git a/asmrun/fail.c b/asmrun/fail.c
index d89bcc6582f..a285aa65acb 100644
--- a/asmrun/fail.c
+++ b/asmrun/fail.c
@@ -27,6 +27,8 @@
 #include "stack.h"
 #include "roots.h"
 
+extern int caml_stop_stack_overflow_detection(void);
+
 /* The globals holding predefined exceptions */
 
 typedef value caml_generated_constant[1];
@@ -55,7 +57,10 @@ char * caml_exception_pointer = NULL;
 void caml_raise(value v)
 {
   Unlock_exn();
-  if (caml_exception_pointer == NULL) caml_fatal_uncaught_exception(v);
+  if (caml_exception_pointer == NULL) {
+    caml_stop_stack_overflow_detection();
+    caml_fatal_uncaught_exception(v);
+  }
 
 #ifndef Stack_grows_upwards
 #define PUSHED_AFTER <
diff --git a/asmrun/signals_asm.c b/asmrun/signals_asm.c
index b55561265f1..647c72ee010 100644
--- a/asmrun/signals_asm.c
+++ b/asmrun/signals_asm.c
@@ -172,7 +172,6 @@ DECLARE_SIGNAL_HANDLER(trap_handler)
 #ifdef HAS_STACK_OVERFLOW_DETECTION
 
 static char * system_stack_top;
-static char sig_alt_stack[SIGSTKSZ];
 
 DECLARE_SIGNAL_HANDLER(segv_handler)
 {
@@ -212,6 +211,8 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
 
 /* Initialization of signal stuff */
 
+static int stack_overflow_detection_active = 0;
+
 void caml_init_signals(void)
 {
   /* Bound-check trap handling */
@@ -240,17 +241,57 @@ void caml_init_signals(void)
   {
     stack_t stk;
     struct sigaction act;
-    stk.ss_sp = sig_alt_stack;
+    stk.ss_sp = malloc(SIGSTKSZ);
+    /* Allocate and select an alternate stack for handling signals,
+       especially SIGSEGV signals.
+       Each thread needs its own alternate stack.
+       The alternate stack used to be statically-allocated for the main thread,
+       but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
+       may not be a compile-time constant (issue #10250). */
+    if (stk.ss_sp == NULL)
+      return;
     stk.ss_size = SIGSTKSZ;
     stk.ss_flags = 0;
     SET_SIGACT(act, segv_handler);
     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
     sigemptyset(&act.sa_mask);
     system_stack_top = (char *) &act;
-    if (sigaltstack(&stk, NULL) == 0) { sigaction(SIGSEGV, &act, NULL); }
+    if (sigaltstack(&stk, NULL) == 0) {
+      stack_overflow_detection_active = 1;
+      sigaction(SIGSEGV, &act, NULL);
+    }
   }
 #endif
 #if defined(_WIN32) && !defined(_WIN64)
   caml_win32_overflow_detection();
 #endif
 }
+
+#if defined(HAS_STACK_OVERFLOW_DETECTION)
+static void set_signal_default(int signum)
+{
+  struct sigaction act;
+  sigemptyset(&act.sa_mask);
+  act.sa_handler = SIG_DFL;
+  act.sa_flags = 0;
+  sigaction(signum, &act, NULL);
+}
+#endif
+
+CAMLexport int caml_stop_stack_overflow_detection(void)
+{
+#ifdef HAS_STACK_OVERFLOW_DETECTION
+  if (stack_overflow_detection_active) {
+    stack_t oldstk, stk;
+    stack_overflow_detection_active = 0;
+    stk.ss_flags = SS_DISABLE;
+    set_signal_default(SIGSEGV);
+    if (sigaltstack(&stk, &oldstk) == -1) return -1;
+    /* If caml_setup_stack_overflow_detection failed, we are not using
+       an alternate signal stack.  SS_DISABLE will be set in oldstk,
+       and there is nothing to free in this case. */
+    if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
+  }
+#endif
+  return 0;
+}
diff --git a/asmrun/startup.c b/asmrun/startup.c
index 765d2a8bfc5..aa66ad23fab 100644
--- a/asmrun/startup.c
+++ b/asmrun/startup.c
@@ -125,6 +125,7 @@ void (*caml_termination_hook)(void *) = NULL;
 extern value caml_start_program (void);
 extern void caml_init_ieee_floats (void);
 extern void caml_init_signals (void);
+extern int caml_stop_stack_overflow_detection(void);
 
 void caml_main(char **argv)
 {
@@ -156,10 +157,12 @@ void caml_main(char **argv)
 #endif
   caml_sys_init(exe_name, argv);
   if (sigsetjmp(caml_termination_jmpbuf.buf, 0)) {
+    caml_stop_stack_overflow_detection();
     if (caml_termination_hook != NULL) caml_termination_hook(NULL);
     return;
   }
   res = caml_start_program();
+  caml_stop_stack_overflow_detection();
   if (Is_exception_result(res))
     caml_fatal_uncaught_exception(Extract_exception(res));
 }
diff --git a/byterun/sys.c b/byterun/sys.c
index bbc0e605f4d..fc87dd19fa8 100644
--- a/byterun/sys.c
+++ b/byterun/sys.c
@@ -97,10 +97,15 @@ CAMLexport void caml_sys_io_error(value arg)
   }
 }
 
+extern int caml_stop_stack_overflow_detection(void);
+
 CAMLprim value caml_sys_exit(value retcode)
 {
 #ifndef NATIVE_CODE
   caml_debugger(PROGRAM_EXIT);
+#endif
+#ifdef NATIVE_CODE
+  caml_stop_stack_overflow_detection();
 #endif
   exit(Int_val(retcode));
   return Val_unit;
