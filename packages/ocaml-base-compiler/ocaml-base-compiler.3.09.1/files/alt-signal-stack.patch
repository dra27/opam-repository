From 07438a63c75f9337184fad2e23999a6ff9fbdc41 Mon Sep 17 00:00:00 2001
From: Xavier Leroy <xavierleroy@users.noreply.github.com>
Date: Fri, 5 Mar 2021 19:14:07 +0100
Subject: [PATCH] Dynamically allocate the alternate signal stack

In Glibc 2.34 and later, SIGSTKSZ may not be a compile-time constant.
It is no longer possible to statically allocate the alternate signal
stack for the main thread, as we've been doing for the last 25 years.

This commit implements dynamic allocation of the alternate signal stack
even for the main thread.  It reuses the code already in place to allocate
the alternate signal stack for other threads.

The alternate signal stack is freed when the main OCaml code / an OCaml thread
stops.

(partial back-port of PR#10266 and PR#10726)
---
 asmrun/fail.c    |  7 ++++++-
 asmrun/signals.c | 47 ++++++++++++++++++++++++++++++++++++++++++++---
 asmrun/startup.c |  3 +++
 byterun/sys.c    |  5 +++++
 4 files changed, 58 insertions(+), 4 deletions(-)

diff --git a/asmrun/fail.c b/asmrun/fail.c
index d00014ef291..96304bff0ea 100644
--- a/asmrun/fail.c
+++ b/asmrun/fail.c
@@ -27,6 +27,8 @@
 #include "stack.h"
 #include "roots.h"
 
+extern int caml_stop_stack_overflow_detection(void);
+
 /* The globals holding predefined exceptions */
 
 typedef value caml_generated_constant[1];
@@ -55,7 +57,10 @@ char * caml_exception_pointer = NULL;
 void caml_raise(value v)
 {
   Unlock_exn();
-  if (caml_exception_pointer == NULL) caml_fatal_uncaught_exception(v);
+  if (caml_exception_pointer == NULL) {
+    caml_stop_stack_overflow_detection();
+    caml_fatal_uncaught_exception(v);
+  }
 
 #ifndef Stack_grows_upwards
 #define PUSHED_AFTER <
diff --git a/asmrun/signals.c b/asmrun/signals.c
index 061a381e579..a3e7e6defe9 100644
--- a/asmrun/signals.c
+++ b/asmrun/signals.c
@@ -400,7 +400,6 @@ DECLARE_SIGNAL_HANDLER(trap_handler)
 #ifdef HAS_STACK_OVERFLOW_DETECTION
 
 static char * system_stack_top;
-static char sig_alt_stack[SIGSTKSZ];
 
 DECLARE_SIGNAL_HANDLER(segv_handler)
 {
@@ -440,6 +439,8 @@ DECLARE_SIGNAL_HANDLER(segv_handler)
 
 /* Initialization of signal stuff */
 
+static int stack_overflow_detection_active = 0;
+
 void caml_init_signals(void)
 {
   /* Bound-check trap handling */
@@ -468,14 +469,54 @@ void caml_init_signals(void)
   {
     stack_t stk;
     struct sigaction act;
-    stk.ss_sp = sig_alt_stack;
+    stk.ss_sp = malloc(SIGSTKSZ);
+    /* Allocate and select an alternate stack for handling signals,
+       especially SIGSEGV signals.
+       Each thread needs its own alternate stack.
+       The alternate stack used to be statically-allocated for the main thread,
+       but this is incompatible with Glibc 2.34 and newer, where SIGSTKSZ
+       may not be a compile-time constant (issue #10250). */
+    if (stk.ss_sp == NULL)
+      return;
     stk.ss_size = SIGSTKSZ;
     stk.ss_flags = 0;
     SET_SIGACT(act, segv_handler);
     act.sa_flags |= SA_ONSTACK | SA_NODEFER;
     sigemptyset(&act.sa_mask);
     system_stack_top = (char *) &act;
-    if (sigaltstack(&stk, NULL) == 0) { sigaction(SIGSEGV, &act, NULL); }
+    if (sigaltstack(&stk, NULL) == 0) {
+      stack_overflow_detection_active = 1;
+      sigaction(SIGSEGV, &act, NULL);
+    }
+  }
+#endif
+}
+
+#if defined(HAS_STACK_OVERFLOW_DETECTION)
+static void set_signal_default(int signum)
+{
+  struct sigaction act;
+  sigemptyset(&act.sa_mask);
+  act.sa_handler = SIG_DFL;
+  act.sa_flags = 0;
+  sigaction(signum, &act, NULL);
+}
+#endif
+
+CAMLexport int caml_stop_stack_overflow_detection(void)
+{
+#ifdef HAS_STACK_OVERFLOW_DETECTION
+  if (stack_overflow_detection_active) {
+    stack_t oldstk, stk;
+    stack_overflow_detection_active = 0;
+    stk.ss_flags = SS_DISABLE;
+    set_signal_default(SIGSEGV);
+    if (sigaltstack(&stk, &oldstk) == -1) return -1;
+    /* If caml_setup_stack_overflow_detection failed, we are not using
+       an alternate signal stack.  SS_DISABLE will be set in oldstk,
+       and there is nothing to free in this case. */
+    if (! (oldstk.ss_flags & SS_DISABLE)) free(oldstk.ss_sp);
   }
 #endif
+  return 0;
 }
diff --git a/asmrun/startup.c b/asmrun/startup.c
index 44aab0ccf53..68c62fb2334 100644
--- a/asmrun/startup.c
+++ b/asmrun/startup.c
@@ -123,6 +123,7 @@ void (*caml_termination_hook)(void *) = NULL;
 extern value caml_start_program (void);
 extern void caml_init_ieee_floats (void);
 extern void caml_init_signals (void);
+extern int caml_stop_stack_overflow_detection(void);
 
 void caml_main(char **argv)
 {
@@ -154,10 +155,12 @@ void caml_main(char **argv)
 #endif
   caml_sys_init(exe_name, argv);
   if (sigsetjmp(caml_termination_jmpbuf.buf, 0)) {
+    caml_stop_stack_overflow_detection();
     if (caml_termination_hook != NULL) caml_termination_hook(NULL);
     return;
   }
   res = caml_start_program();
+  caml_stop_stack_overflow_detection();
   if (Is_exception_result(res))
     caml_fatal_uncaught_exception(Extract_exception(res));
 }
diff --git a/byterun/sys.c b/byterun/sys.c
index f62b903bf50..7fd0f94f06c 100644
--- a/byterun/sys.c
+++ b/byterun/sys.c
@@ -92,10 +92,15 @@ CAMLexport void caml_sys_error(value arg)
   CAMLnoreturn;
 }
 
+extern int caml_stop_stack_overflow_detection(void);
+
 CAMLprim value caml_sys_exit(value retcode)
 {
 #ifndef NATIVE_CODE
   caml_debugger(PROGRAM_EXIT);
+#endif
+#ifdef NATIVE_CODE
+  caml_stop_stack_overflow_detection();
 #endif
   exit(Int_val(retcode));
   return Val_unit;
